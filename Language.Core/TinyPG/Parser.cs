// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

// Disable unused variable warnings which
// can happen during the parser generation.
#pragma warning disable 168

namespace TinyPG
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

         public ParseTree Parse(string input)
        {
            return Parse(input, "", new ParseTree());
        }

        public ParseTree Parse(string input, string fileName)
        {
            return Parse(input, fileName, new ParseTree());
        }

        public ParseTree Parse(string input, string fileName, ParseTree tree)
        {
            scanner.Init(input, fileName);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent) // NonTerminalSymbol: Start
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.GLOBAL, TokenType.IDENTIFIER); // Option Rule
            if (tok.Type == TokenType.GLOBAL
                || tok.Type == TokenType.IDENTIFIER)
            {
                ParseProgram(node); // NonTerminal Rule: Program
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOF); // Terminal Rule: EOF
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Start

        private void ParseProgram(ParseNode parent) // NonTerminalSymbol: Program
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Program), "Program");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseMember(node); // NonTerminal Rule: Member

             // Concat Rule
            tok = scanner.LookAhead(TokenType.NEWLINE); // ZeroOrMore Rule
            while (tok.Type == TokenType.NEWLINE)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.NEWLINE); // Terminal Rule: NEWLINE
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.NEWLINE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NEWLINE.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.GLOBAL, TokenType.IDENTIFIER); // Option Rule
                if (tok.Type == TokenType.GLOBAL
                    || tok.Type == TokenType.IDENTIFIER)
                {
                    ParseMember(node); // NonTerminal Rule: Member
                }
            tok = scanner.LookAhead(TokenType.NEWLINE); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Program

        private void ParseMember(ParseNode parent) // NonTerminalSymbol: Member
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Member), "Member");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.GLOBAL, TokenType.IDENTIFIER); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.GLOBAL:
                    ParseGlobalvar(node); // NonTerminal Rule: Globalvar
                    break;
                case TokenType.IDENTIFIER:
                    ParseFunction(node); // NonTerminal Rule: Function
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected GLOBAL or IDENTIFIER.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Member

        private void ParseGlobalvar(ParseNode parent) // NonTerminalSymbol: Globalvar
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Globalvar), "Globalvar");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.GLOBAL); // Terminal Rule: GLOBAL
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.GLOBAL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GLOBAL.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.ASSIGN); // Option Rule
            if (tok.Type == TokenType.ASSIGN)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.ASSIGN); // Terminal Rule: ASSIGN
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ASSIGN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ASSIGN.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseLiteral(node); // NonTerminal Rule: Literal
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Globalvar

        private void ParseFunction(ParseNode parent) // NonTerminalSymbol: Function
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Function), "Function");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BROPEN); // Option Rule
            if (tok.Type == TokenType.BROPEN)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.BROPEN); // Terminal Rule: BROPEN
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BROPEN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseParameters(node); // NonTerminal Rule: Parameters

                 // Concat Rule
                tok = scanner.Scan(TokenType.BRCLOSE); // Terminal Rule: BRCLOSE
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRCLOSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.ARROW, TokenType.IF, TokenType.WHILE, TokenType.DO, TokenType.FOR, TokenType.RETURN, TokenType.IDENTIFIER, TokenType.OPER, TokenType.END); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.ARROW:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.ARROW); // Terminal Rule: ARROW
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ARROW) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARROW.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    ParseExpr(node); // NonTerminal Rule: Expr
                    break;
                case TokenType.IF:
                case TokenType.WHILE:
                case TokenType.DO:
                case TokenType.FOR:
                case TokenType.RETURN:
                case TokenType.IDENTIFIER:
                case TokenType.OPER:
                case TokenType.END:
                    ParseStatements(node); // NonTerminal Rule: Statements
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected ARROW, IF, WHILE, DO, FOR, RETURN, IDENTIFIER, OPER, or END.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Function

        private void ParseParameters(ParseNode parent) // NonTerminalSymbol: Parameters
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Parameters), "Parameters");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            while (tok.Type == TokenType.COMMA)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                    return;
                }
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Parameters

        private void ParseStatements(ParseNode parent) // NonTerminalSymbol: Statements
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Statements), "Statements");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.IF, TokenType.WHILE, TokenType.DO, TokenType.FOR, TokenType.RETURN, TokenType.IDENTIFIER, TokenType.OPER); // Option Rule
            if (tok.Type == TokenType.IF
                || tok.Type == TokenType.WHILE
                || tok.Type == TokenType.DO
                || tok.Type == TokenType.FOR
                || tok.Type == TokenType.RETURN
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.OPER)
            {

                 // Concat Rule
                ParseStatement(node); // NonTerminal Rule: Statement

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.NEWLINE); // ZeroOrMore Rule
                while (tok.Type == TokenType.NEWLINE)
                {

                     // Concat Rule
                    tok = scanner.Scan(TokenType.NEWLINE); // Terminal Rule: NEWLINE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NEWLINE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NEWLINE.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.IF, TokenType.WHILE, TokenType.DO, TokenType.FOR, TokenType.RETURN, TokenType.IDENTIFIER, TokenType.OPER); // Option Rule
                    if (tok.Type == TokenType.IF
                        || tok.Type == TokenType.WHILE
                        || tok.Type == TokenType.DO
                        || tok.Type == TokenType.FOR
                        || tok.Type == TokenType.RETURN
                        || tok.Type == TokenType.IDENTIFIER
                        || tok.Type == TokenType.OPER)
                    {
                        ParseStatement(node); // NonTerminal Rule: Statement
                    }
                tok = scanner.LookAhead(TokenType.NEWLINE); // ZeroOrMore Rule
                }
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.END); // Terminal Rule: END
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.END) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.END.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Statements

        private void ParseStatement(ParseNode parent) // NonTerminalSymbol: Statement
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Statement), "Statement");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.IF, TokenType.WHILE, TokenType.DO, TokenType.FOR, TokenType.RETURN, TokenType.IDENTIFIER, TokenType.OPER); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.IF:
                    ParseIfStm(node); // NonTerminal Rule: IfStm
                    break;
                case TokenType.WHILE:
                    ParseWhileStm(node); // NonTerminal Rule: WhileStm
                    break;
                case TokenType.DO:
                    ParseDoStm(node); // NonTerminal Rule: DoStm
                    break;
                case TokenType.FOR:
                    ParseForStm(node); // NonTerminal Rule: ForStm
                    break;
                case TokenType.RETURN:
                    ParseReturnStm(node); // NonTerminal Rule: ReturnStm
                    break;
                case TokenType.IDENTIFIER:
                    ParseCallOrAssign(node); // NonTerminal Rule: CallOrAssign
                    break;
                case TokenType.OPER:
                    ParseOperStm(node); // NonTerminal Rule: OperStm
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected IF, WHILE, DO, FOR, RETURN, IDENTIFIER, or OPER.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Statement

        private void ParseIfStm(ParseNode parent) // NonTerminalSymbol: IfStm
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.IfStm), "IfStm");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IF); // Terminal Rule: IF
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IF.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseExpr(node); // NonTerminal Rule: Expr

             // Concat Rule
            ParseStatements(node); // NonTerminal Rule: Statements

             // Concat Rule
            tok = scanner.LookAhead(TokenType.ELSE); // Option Rule
            if (tok.Type == TokenType.ELSE)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.ELSE); // Terminal Rule: ELSE
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ELSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ELSE.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseStatements(node); // NonTerminal Rule: Statements
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: IfStm

        private void ParseWhileStm(ParseNode parent) // NonTerminalSymbol: WhileStm
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.WhileStm), "WhileStm");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.WHILE); // Terminal Rule: WHILE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WHILE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHILE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.NOT, TokenType.UNARYOP, TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.BOOL, TokenType.READFUNC, TokenType.IDENTIFIER, TokenType.BROPEN); // Option Rule
            if (tok.Type == TokenType.NOT
                || tok.Type == TokenType.UNARYOP
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DOUBLE
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.BOOL
                || tok.Type == TokenType.READFUNC
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.BROPEN)
            {
                ParseExpr(node); // NonTerminal Rule: Expr
            }

             // Concat Rule
            ParseStatements(node); // NonTerminal Rule: Statements

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: WhileStm

        private void ParseDoStm(ParseNode parent) // NonTerminalSymbol: DoStm
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.DoStm), "DoStm");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.DO); // Terminal Rule: DO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseStatements(node); // NonTerminal Rule: Statements

             // Concat Rule
            tok = scanner.Scan(TokenType.WHILE); // Terminal Rule: WHILE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WHILE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHILE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseExpr(node); // NonTerminal Rule: Expr

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: DoStm

        private void ParseForStm(ParseNode parent) // NonTerminalSymbol: ForStm
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ForStm), "ForStm");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.FOR); // Terminal Rule: FOR
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FOR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOR.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseCallOrAssign(node); // NonTerminal Rule: CallOrAssign

             // Concat Rule
            tok = scanner.Scan(TokenType.TO); // Terminal Rule: TO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseExpr(node); // NonTerminal Rule: Expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.INCBY); // Option Rule
            if (tok.Type == TokenType.INCBY)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.INCBY); // Terminal Rule: INCBY
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.INCBY) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INCBY.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseExpr(node); // NonTerminal Rule: Expr
            }

             // Concat Rule
            ParseStatements(node); // NonTerminal Rule: Statements

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ForStm

        private void ParseReturnStm(ParseNode parent) // NonTerminalSymbol: ReturnStm
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ReturnStm), "ReturnStm");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.RETURN); // Terminal Rule: RETURN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RETURN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RETURN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseExpr(node); // NonTerminal Rule: Expr

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ReturnStm

        private void ParseOperStm(ParseNode parent) // NonTerminalSymbol: OperStm
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.OperStm), "OperStm");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.OPER); // Terminal Rule: OPER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OPER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BROPEN); // Option Rule
            if (tok.Type == TokenType.BROPEN)
            {
                ParseCall(node); // NonTerminal Rule: Call
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: OperStm

        private void ParseCallOrAssign(ParseNode parent) // NonTerminalSymbol: CallOrAssign
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CallOrAssign), "CallOrAssign");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseVariable(node); // NonTerminal Rule: Variable

             // Concat Rule
            tok = scanner.LookAhead(TokenType.ASSIGN); // Option Rule
            if (tok.Type == TokenType.ASSIGN)
            {
                ParseAssign(node); // NonTerminal Rule: Assign
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CallOrAssign

        private void ParseAssign(ParseNode parent) // NonTerminalSymbol: Assign
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Assign), "Assign");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.ASSIGN); // Terminal Rule: ASSIGN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ASSIGN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ASSIGN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseExpr(node); // NonTerminal Rule: Expr

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Assign

        private void ParseVariable(ParseNode parent) // NonTerminalSymbol: Variable
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Variable), "Variable");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.SQOPEN, TokenType.BROPEN); // Option Rule
            if (tok.Type == TokenType.SQOPEN
                || tok.Type == TokenType.BROPEN)
            {
                tok = scanner.LookAhead(TokenType.SQOPEN, TokenType.BROPEN); // Choice Rule
                switch (tok.Type)
                { // Choice Rule
                    case TokenType.SQOPEN:
                        ParseArray(node); // NonTerminal Rule: Array
                        break;
                    case TokenType.BROPEN:
                        ParseCall(node); // NonTerminal Rule: Call
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected SQOPEN or BROPEN.", 0x0002, tok));
                        break;
                } // Choice Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Variable

        private void ParseArray(ParseNode parent) // NonTerminalSymbol: Array
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Array), "Array");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.SQOPEN); // Terminal Rule: SQOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SQOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseExpr(node); // NonTerminal Rule: Expr

             // Concat Rule
            tok = scanner.Scan(TokenType.SQCLOSE); // Terminal Rule: SQCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SQCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQCLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Array

        private void ParseCall(ParseNode parent) // NonTerminalSymbol: Call
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Call), "Call");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.BROPEN); // Terminal Rule: BROPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BROPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.NOT, TokenType.UNARYOP, TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.BOOL, TokenType.READFUNC, TokenType.IDENTIFIER, TokenType.BROPEN); // Option Rule
            if (tok.Type == TokenType.NOT
                || tok.Type == TokenType.UNARYOP
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DOUBLE
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.BOOL
                || tok.Type == TokenType.READFUNC
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.BROPEN)
            {
                ParseArguments(node); // NonTerminal Rule: Arguments
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.BRCLOSE); // Terminal Rule: BRCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Call

        private void ParseArguments(ParseNode parent) // NonTerminalSymbol: Arguments
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Arguments), "Arguments");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseExpr(node); // NonTerminal Rule: Expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            while (tok.Type == TokenType.COMMA)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseExpr(node); // NonTerminal Rule: Expr
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Arguments

        private void ParseLiteral(ParseNode parent) // NonTerminalSymbol: Literal
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Literal), "Literal");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.BOOL, TokenType.READFUNC); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.INTEGER:
                    tok = scanner.Scan(TokenType.INTEGER); // Terminal Rule: INTEGER
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INTEGER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.DOUBLE:
                    tok = scanner.Scan(TokenType.DOUBLE); // Terminal Rule: DOUBLE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOUBLE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLE.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.BOOL:
                    tok = scanner.Scan(TokenType.BOOL); // Terminal Rule: BOOL
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BOOL) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BOOL.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.READFUNC:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.READFUNC); // Terminal Rule: READFUNC
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.READFUNC) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.READFUNC.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.BROPEN); // Option Rule
                    if (tok.Type == TokenType.BROPEN)
                    {
                        ParseCall(node); // NonTerminal Rule: Call
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected INTEGER, DOUBLE, STRING, BOOL, or READFUNC.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Literal

        private void ParseExpr(ParseNode parent) // NonTerminalSymbol: Expr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Expr), "Expr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseOrExpr(node); // NonTerminal Rule: OrExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.QUESTION); // Option Rule
            if (tok.Type == TokenType.QUESTION)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.QUESTION); // Terminal Rule: QUESTION
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.QUESTION) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.QUESTION.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseExpr(node); // NonTerminal Rule: Expr

                 // Concat Rule
                tok = scanner.Scan(TokenType.COLON); // Terminal Rule: COLON
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COLON) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseExpr(node); // NonTerminal Rule: Expr
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Expr

        private void ParseOrExpr(ParseNode parent) // NonTerminalSymbol: OrExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.OrExpr), "OrExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseAndExpr(node); // NonTerminal Rule: AndExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.OR); // ZeroOrMore Rule
            while (tok.Type == TokenType.OR)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.OR); // Terminal Rule: OR
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.OR) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OR.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseAndExpr(node); // NonTerminal Rule: AndExpr
            tok = scanner.LookAhead(TokenType.OR); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: OrExpr

        private void ParseAndExpr(ParseNode parent) // NonTerminalSymbol: AndExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AndExpr), "AndExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseNotExpr(node); // NonTerminal Rule: NotExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.AND); // ZeroOrMore Rule
            while (tok.Type == TokenType.AND)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.AND); // Terminal Rule: AND
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.AND) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AND.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseNotExpr(node); // NonTerminal Rule: NotExpr
            tok = scanner.LookAhead(TokenType.AND); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: AndExpr

        private void ParseNotExpr(ParseNode parent) // NonTerminalSymbol: NotExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.NotExpr), "NotExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.NOT); // Option Rule
            if (tok.Type == TokenType.NOT)
            {
                tok = scanner.Scan(TokenType.NOT); // Terminal Rule: NOT
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.NOT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NOT.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            ParseCompExpr(node); // NonTerminal Rule: CompExpr

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: NotExpr

        private void ParseCompExpr(ParseNode parent) // NonTerminalSymbol: CompExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CompExpr), "CompExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseAddExpr(node); // NonTerminal Rule: AddExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMP); // Option Rule
            if (tok.Type == TokenType.COMP)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMP); // Terminal Rule: COMP
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMP) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMP.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseAddExpr(node); // NonTerminal Rule: AddExpr
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CompExpr

        private void ParseAddExpr(ParseNode parent) // NonTerminalSymbol: AddExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AddExpr), "AddExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseMultExpr(node); // NonTerminal Rule: MultExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.PLUSMINUS); // ZeroOrMore Rule
            while (tok.Type == TokenType.PLUSMINUS)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.PLUSMINUS); // Terminal Rule: PLUSMINUS
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.PLUSMINUS) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUSMINUS.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseMultExpr(node); // NonTerminal Rule: MultExpr
            tok = scanner.LookAhead(TokenType.PLUSMINUS); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: AddExpr

        private void ParseMultExpr(ParseNode parent) // NonTerminalSymbol: MultExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MultExpr), "MultExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParsePowExpr(node); // NonTerminal Rule: PowExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.MULTDIV); // ZeroOrMore Rule
            while (tok.Type == TokenType.MULTDIV)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.MULTDIV); // Terminal Rule: MULTDIV
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.MULTDIV) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULTDIV.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParsePowExpr(node); // NonTerminal Rule: PowExpr
            tok = scanner.LookAhead(TokenType.MULTDIV); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: MultExpr

        private void ParsePowExpr(ParseNode parent) // NonTerminalSymbol: PowExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.PowExpr), "PowExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseUnaryExpr(node); // NonTerminal Rule: UnaryExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.POW); // ZeroOrMore Rule
            while (tok.Type == TokenType.POW)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.POW); // Terminal Rule: POW
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.POW) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POW.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseUnaryExpr(node); // NonTerminal Rule: UnaryExpr
            tok = scanner.LookAhead(TokenType.POW); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: PowExpr

        private void ParseUnaryExpr(ParseNode parent) // NonTerminalSymbol: UnaryExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.UnaryExpr), "UnaryExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.UNARYOP); // Option Rule
            if (tok.Type == TokenType.UNARYOP)
            {
                tok = scanner.Scan(TokenType.UNARYOP); // Terminal Rule: UNARYOP
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.UNARYOP) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNARYOP.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            ParseAtom(node); // NonTerminal Rule: Atom

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: UnaryExpr

        private void ParseAtom(ParseNode parent) // NonTerminalSymbol: Atom
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Atom), "Atom");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.BOOL, TokenType.READFUNC, TokenType.IDENTIFIER, TokenType.BROPEN); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.INTEGER:
                case TokenType.DOUBLE:
                case TokenType.STRING:
                case TokenType.BOOL:
                case TokenType.READFUNC:
                    ParseLiteral(node); // NonTerminal Rule: Literal
                    break;
                case TokenType.IDENTIFIER:
                    ParseVariable(node); // NonTerminal Rule: Variable
                    break;
                case TokenType.BROPEN:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.BROPEN); // Terminal Rule: BROPEN
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BROPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    ParseExpr(node); // NonTerminal Rule: Expr

                     // Concat Rule
                    tok = scanner.Scan(TokenType.BRCLOSE); // Terminal Rule: BRCLOSE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRCLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected INTEGER, DOUBLE, STRING, BOOL, READFUNC, IDENTIFIER, or BROPEN.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Atom


    }

    #endregion Parser
}
