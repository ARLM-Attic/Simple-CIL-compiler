// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;



namespace TinyPG
{
    #region ParseTree

    /// <summary>
    /// Errors list.
    /// </summary>
    [Serializable]
    public class ParseErrors : List<ParseError>
    {

    }
    
    /// <summary>
    /// Parsing error.
    /// </summary>
    [Serializable]
    public class ParseError
    {
        private string file;
        private string message;
        private int code;
        private int line;
        private int col;
        private int pos;
        private int length;

        public string File { get { return file; } }

        public int Code { get { return code; } }

        public int Line { get { return line; } }

        public int Column { get { return col; } }

        public int Position { get { return pos; } }

        public int Length { get { return length; } }

        public string Message { get { return message; } }

        // just for the sake of serialization
        public ParseError()
        {
        }

        public ParseError(string message, int code, ParseNode node) : this(message, code, node.Token)
        {
        }

        public ParseError(string message, int code, Token token) : this(message, code, token.File, token.Line, token.Column, token.StartPos, token.Length)
        {
        }

        public ParseError(string message, int code) : this(message, code, string.Empty, 0, 0, 0, 0)
        {
        }

        public ParseError(string message, int code, string file, int line, int col, int pos, int length)
        {
            this.file = file;
            this.message = message;
            this.code = code;
            this.line = line;
            this.col = col;
            this.pos = pos;
            this.length = length;
        }

        public override string ToString()
        {
            // ReSharper disable once UseStringInterpolation
            return string.Format("({1}:{2}) {0}", Message, Line, Column);
        }
    }

    /// <summary>
    /// Parse tree root.
    /// </summary>
    [Serializable]
    public partial class ParseTree : ParseNode
    {
        /// <summary>
        /// Parse errors.
        /// </summary>
        public ParseErrors Errors;
        
        /// <summary>
        /// Skipped tokens.
        /// </summary>
        public List<Token> Skipped;

        public ParseTree() : base(new Token(), "ParseTree")
        {
            Token.Type = TokenType.Start;
            Token.Text = "Root";
            Errors = new ParseErrors();
            Instance = this;
        }

        public static ParseTree Instance{get;set;}
        
        /// <summary>
        /// Get tree as formatted string.
        /// </summary>
        public string PrintTree()
        {
            StringBuilder sb = new StringBuilder();
            int indent = 0;
            PrintNode(sb, this, indent);
            return sb.ToString();
        }

        private void PrintNode(StringBuilder sb, ParseNode node, int indent)
        {
            
            string space = "".PadLeft(indent, ' ');

            sb.Append(space);
            sb.AppendLine(node.Text);

            foreach (ParseNode n in node.Nodes)
                PrintNode(sb, n, indent + 2);
        }
        
        /// <summary>
        /// Entry point for tree eval.
        /// </summary>
        /// <param name="paramlist">Additional optional params.</param>
        /// <returns>Eval result.</returns>
        public object Eval(params object[] paramlist)
        {
            return Nodes[0].Eval(this, paramlist);
        }
    }

    /// <summary>
    /// Parse node.
    /// </summary>
    [Serializable]
    [XmlInclude(typeof(ParseTree))]
    public partial class ParseNode
    {
        protected string text;
        protected List<ParseNode> nodes;
        
        
        /// <summary>
        /// Child elements.
        /// </summary>
        public List<ParseNode> Nodes { get {return nodes;} set{nodes = value;} }
        

        /// <summary>
        /// Parent element.
        /// </summary>
        [XmlIgnore] // avoid circular references when serializing
        public ParseNode Parent;
        
        /// <summary>
        /// Token.
        /// </summary>
        public Token Token; // the token/rule
        
        /// <summary>
        /// Displaying text.
        /// </summary>
        [XmlIgnore]
        public string Text
        {
            get { return text;} 
            set { text = value; }
        } 

        public virtual ParseNode CreateNode(Token token, string text)
        {
            ParseNode node = new ParseNode(token, text);
            node.Parent = this;
            return node;
        }

        protected ParseNode(Token token, string text)
        {
            this.Token = token;
            this.text = text;
            this.nodes = new List<ParseNode>();
        }

        protected object GetValue(ParseTree tree, TokenType type, int index)
        {
            return GetValue(tree, type, ref index);
        }

        protected object GetValue(ParseTree tree, TokenType type, ref int index)
        {
            object o = null;
            if (index < 0) return o;

            // left to right
            foreach (ParseNode node in nodes)
            {
                if (node.Token.Type == type)
                {
                    index--;
                    if (index < 0)
                    {
                        o = node.Eval(tree);
                        break;
                    }
                }
            }
            return o;
        }

        /// <summary>
        /// this implements the evaluation functionality, cannot be used directly
        /// </summary>
        /// <param name="tree">the parsetree itself</param>
        /// <param name="paramlist">optional input parameters</param>
        /// <returns>a partial result of the evaluation</returns>
        internal object Eval(ParseTree tree, params object[] paramlist)
        {
            object Value = null;
            
            switch (Token.Type)
            {
                case TokenType.Start:
                    Value = EvalStart(tree, paramlist);
                    break;
                case TokenType.Program:
                    Value = EvalProgram(tree, paramlist);
                    break;
                case TokenType.Member:
                    Value = EvalMember(tree, paramlist);
                    break;
                case TokenType.Globalvar:
                    Value = EvalGlobalvar(tree, paramlist);
                    break;
                case TokenType.Function:
                    Value = EvalFunction(tree, paramlist);
                    break;
                case TokenType.Parameters:
                    Value = EvalParameters(tree, paramlist);
                    break;
                case TokenType.Statements:
                    Value = EvalStatements(tree, paramlist);
                    break;
                case TokenType.Statement:
                    Value = EvalStatement(tree, paramlist);
                    break;
                case TokenType.IfStm:
                    Value = EvalIfStm(tree, paramlist);
                    break;
                case TokenType.WhileStm:
                    Value = EvalWhileStm(tree, paramlist);
                    break;
                case TokenType.DoStm:
                    Value = EvalDoStm(tree, paramlist);
                    break;
                case TokenType.ForStm:
                    Value = EvalForStm(tree, paramlist);
                    break;
                case TokenType.ReturnStm:
                    Value = EvalReturnStm(tree, paramlist);
                    break;
                case TokenType.OperStm:
                    Value = EvalOperStm(tree, paramlist);
                    break;
                case TokenType.CallOrAssign:
                    Value = EvalCallOrAssign(tree, paramlist);
                    break;
                case TokenType.Assign:
                    Value = EvalAssign(tree, paramlist);
                    break;
                case TokenType.Variable:
                    Value = EvalVariable(tree, paramlist);
                    break;
                case TokenType.Array:
                    Value = EvalArray(tree, paramlist);
                    break;
                case TokenType.Call:
                    Value = EvalCall(tree, paramlist);
                    break;
                case TokenType.Arguments:
                    Value = EvalArguments(tree, paramlist);
                    break;
                case TokenType.Literal:
                    Value = EvalLiteral(tree, paramlist);
                    break;
                case TokenType.Expr:
                    Value = EvalExpr(tree, paramlist);
                    break;
                case TokenType.OrExpr:
                    Value = EvalOrExpr(tree, paramlist);
                    break;
                case TokenType.AndExpr:
                    Value = EvalAndExpr(tree, paramlist);
                    break;
                case TokenType.NotExpr:
                    Value = EvalNotExpr(tree, paramlist);
                    break;
                case TokenType.CompExpr:
                    Value = EvalCompExpr(tree, paramlist);
                    break;
                case TokenType.AddExpr:
                    Value = EvalAddExpr(tree, paramlist);
                    break;
                case TokenType.MultExpr:
                    Value = EvalMultExpr(tree, paramlist);
                    break;
                case TokenType.PowExpr:
                    Value = EvalPowExpr(tree, paramlist);
                    break;
                case TokenType.UnaryExpr:
                    Value = EvalUnaryExpr(tree, paramlist);
                    break;
                case TokenType.Atom:
                    Value = EvalAtom(tree, paramlist);
                    break;

                default:
                    Value = Token.Text;
                    break;
            }
            return Value;
        }

        /// <summary>
        /// Rule: Start -> (Program)? EOF ;
        /// </summary>
        protected virtual object EvalStart(ParseTree tree, params object[] paramlist)
        {
            return "Could not interpret input; no semantics implemented.";
        }

        /// <summary>
        /// Rule: Program -> Member (NEWLINE (Member)? )* ;
        /// </summary>
        protected virtual object EvalProgram(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: Member -> (Globalvar | Function);
        /// </summary>
        protected virtual object EvalMember(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: Globalvar -> GLOBAL IDENTIFIER (ASSIGN Literal )? ;
        /// </summary>
        protected virtual object EvalGlobalvar(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: Function -> IDENTIFIER (BROPEN Parameters BRCLOSE )? (ARROW Expr  | Statements) ;
        /// </summary>
        protected virtual object EvalFunction(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: Parameters -> IDENTIFIER (COMMA IDENTIFIER )* ;
        /// </summary>
        protected virtual object EvalParameters(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: Statements -> (Statement (NEWLINE (Statement)? )* )? END ;
        /// </summary>
        protected virtual object EvalStatements(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: Statement -> (IfStm | WhileStm | DoStm | ForStm | ReturnStm | CallOrAssign | OperStm);
        /// </summary>
        protected virtual object EvalStatement(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: IfStm -> IF Expr Statements (ELSE Statements )? ;
        /// </summary>
        protected virtual object EvalIfStm(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: WhileStm -> WHILE (Expr)? Statements ;
        /// </summary>
        protected virtual object EvalWhileStm(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: DoStm -> DO Statements WHILE Expr ;
        /// </summary>
        protected virtual object EvalDoStm(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: ForStm -> FOR CallOrAssign TO Expr (INCBY Expr )? Statements ;
        /// </summary>
        protected virtual object EvalForStm(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: ReturnStm -> RETURN Expr ;
        /// </summary>
        protected virtual object EvalReturnStm(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: OperStm -> OPER (Call)? ;
        /// </summary>
        protected virtual object EvalOperStm(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: CallOrAssign -> Variable (Assign)? ;
        /// </summary>
        protected virtual object EvalCallOrAssign(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: Assign -> ASSIGN Expr ;
        /// </summary>
        protected virtual object EvalAssign(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: Variable -> IDENTIFIER ((Array | Call))? ;
        /// </summary>
        protected virtual object EvalVariable(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: Array -> SQOPEN Expr SQCLOSE ;
        /// </summary>
        protected virtual object EvalArray(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: Call -> BROPEN (Arguments)? BRCLOSE ;
        /// </summary>
        protected virtual object EvalCall(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: Arguments -> Expr (COMMA Expr )* ;
        /// </summary>
        protected virtual object EvalArguments(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: Literal -> (INTEGER | DOUBLE | STRING | BOOL | READFUNC (Call)? );
        /// </summary>
        protected virtual object EvalLiteral(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: Expr -> OrExpr (QUESTION Expr COLON Expr )? ;
        /// </summary>
        protected virtual object EvalExpr(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: OrExpr -> AndExpr (OR AndExpr )* ;
        /// </summary>
        protected virtual object EvalOrExpr(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: AndExpr -> NotExpr (AND NotExpr )* ;
        /// </summary>
        protected virtual object EvalAndExpr(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: NotExpr -> (NOT)? CompExpr ;
        /// </summary>
        protected virtual object EvalNotExpr(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: CompExpr -> AddExpr (COMP AddExpr )? ;
        /// </summary>
        protected virtual object EvalCompExpr(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: AddExpr -> MultExpr (PLUSMINUS MultExpr )* ;
        /// </summary>
        protected virtual object EvalAddExpr(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: MultExpr -> PowExpr (MULTDIV PowExpr )* ;
        /// </summary>
        protected virtual object EvalMultExpr(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: PowExpr -> UnaryExpr (POW UnaryExpr )* ;
        /// </summary>
        protected virtual object EvalPowExpr(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: UnaryExpr -> (UNARYOP)? Atom ;
        /// </summary>
        protected virtual object EvalUnaryExpr(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        /// <summary>
        /// Rule: Atom -> (Literal | Variable | BROPEN Expr BRCLOSE );
        /// </summary>
        protected virtual object EvalAtom(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }


    }
    
    #endregion ParseTree
}
