// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

// Disable unused variable warnings which
// can happen during the parser generation.
#pragma warning disable 168

namespace TinyPG
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

         public ParseTree Parse(string input)
        {
            return Parse(input, "", new ParseTree());
        }

        public ParseTree Parse(string input, string fileName)
        {
            return Parse(input, fileName, new ParseTree());
        }

        public ParseTree Parse(string input, string fileName, ParseTree tree)
        {
            scanner.Init(input, fileName);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.GLOBAL, TokenType.IDENTIFIER);
            if (tok.Type == TokenType.GLOBAL
                || tok.Type == TokenType.IDENTIFIER)
            {
                ParseProgram(node);
            }

            
            tok = scanner.Scan(TokenType.EOF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseProgram(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Program), "Program");
            parent.Nodes.Add(node);


            
            ParseMember(node);

            
            tok = scanner.LookAhead(TokenType.NEWLINE);
            while (tok.Type == TokenType.NEWLINE)
            {

                
                tok = scanner.Scan(TokenType.NEWLINE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.NEWLINE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NEWLINE.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.LookAhead(TokenType.GLOBAL, TokenType.IDENTIFIER);
                if (tok.Type == TokenType.GLOBAL
                    || tok.Type == TokenType.IDENTIFIER)
                {
                    ParseMember(node);
                }
            tok = scanner.LookAhead(TokenType.NEWLINE);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseMember(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Member), "Member");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.GLOBAL, TokenType.IDENTIFIER);
            switch (tok.Type)
            {
                case TokenType.GLOBAL:
                    ParseGlobalvar(node);
                    break;
                case TokenType.IDENTIFIER:
                    ParseFunction(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected GLOBAL or IDENTIFIER.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseGlobalvar(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Globalvar), "Globalvar");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.GLOBAL);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.GLOBAL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GLOBAL.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.ASSIGN);
            if (tok.Type == TokenType.ASSIGN)
            {

                
                tok = scanner.Scan(TokenType.ASSIGN);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ASSIGN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ASSIGN.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseLiteral(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseFunction(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Function), "Function");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.BROPEN);
            if (tok.Type == TokenType.BROPEN)
            {

                
                tok = scanner.Scan(TokenType.BROPEN);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BROPEN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseParameters(node);

                
                tok = scanner.Scan(TokenType.BRCLOSE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRCLOSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, tok));
                    return;
                }
            }

            
            tok = scanner.LookAhead(TokenType.ARROW, TokenType.IF, TokenType.WHILE, TokenType.DO, TokenType.FOR, TokenType.RETURN, TokenType.IDENTIFIER, TokenType.OPER, TokenType.END);
            switch (tok.Type)
            {
                case TokenType.ARROW:

                    
                    tok = scanner.Scan(TokenType.ARROW);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ARROW) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARROW.ToString(), 0x1001, tok));
                        return;
                    }

                    
                    ParseExpr(node);
                    break;
                case TokenType.IF:
                case TokenType.WHILE:
                case TokenType.DO:
                case TokenType.FOR:
                case TokenType.RETURN:
                case TokenType.IDENTIFIER:
                case TokenType.OPER:
                case TokenType.END:
                    ParseStatements(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected ARROW, IF, WHILE, DO, FOR, RETURN, IDENTIFIER, OPER, or END.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseParameters(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Parameters), "Parameters");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.COMMA);
            while (tok.Type == TokenType.COMMA)
            {

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.Scan(TokenType.IDENTIFIER);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                    return;
                }
            tok = scanner.LookAhead(TokenType.COMMA);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseStatements(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Statements), "Statements");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.IF, TokenType.WHILE, TokenType.DO, TokenType.FOR, TokenType.RETURN, TokenType.IDENTIFIER, TokenType.OPER);
            if (tok.Type == TokenType.IF
                || tok.Type == TokenType.WHILE
                || tok.Type == TokenType.DO
                || tok.Type == TokenType.FOR
                || tok.Type == TokenType.RETURN
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.OPER)
            {

                
                ParseStatement(node);

                
                tok = scanner.LookAhead(TokenType.NEWLINE);
                while (tok.Type == TokenType.NEWLINE)
                {

                    
                    tok = scanner.Scan(TokenType.NEWLINE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NEWLINE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NEWLINE.ToString(), 0x1001, tok));
                        return;
                    }

                    
                    tok = scanner.LookAhead(TokenType.IF, TokenType.WHILE, TokenType.DO, TokenType.FOR, TokenType.RETURN, TokenType.IDENTIFIER, TokenType.OPER);
                    if (tok.Type == TokenType.IF
                        || tok.Type == TokenType.WHILE
                        || tok.Type == TokenType.DO
                        || tok.Type == TokenType.FOR
                        || tok.Type == TokenType.RETURN
                        || tok.Type == TokenType.IDENTIFIER
                        || tok.Type == TokenType.OPER)
                    {
                        ParseStatement(node);
                    }
                tok = scanner.LookAhead(TokenType.NEWLINE);
                }
            }

            
            tok = scanner.Scan(TokenType.END);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.END) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.END.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Statement), "Statement");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.IF, TokenType.WHILE, TokenType.DO, TokenType.FOR, TokenType.RETURN, TokenType.IDENTIFIER, TokenType.OPER);
            switch (tok.Type)
            {
                case TokenType.IF:
                    ParseIfStm(node);
                    break;
                case TokenType.WHILE:
                    ParseWhileStm(node);
                    break;
                case TokenType.DO:
                    ParseDoStm(node);
                    break;
                case TokenType.FOR:
                    ParseForStm(node);
                    break;
                case TokenType.RETURN:
                    ParseReturnStm(node);
                    break;
                case TokenType.IDENTIFIER:
                    ParseCallOrAssign(node);
                    break;
                case TokenType.OPER:
                    ParseOperStm(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected IF, WHILE, DO, FOR, RETURN, IDENTIFIER, or OPER.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseIfStm(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.IfStm), "IfStm");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IF.ToString(), 0x1001, tok));
                return;
            }

            
            ParseExpr(node);

            
            ParseStatements(node);

            
            tok = scanner.LookAhead(TokenType.ELSE);
            if (tok.Type == TokenType.ELSE)
            {

                
                tok = scanner.Scan(TokenType.ELSE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ELSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ELSE.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseStatements(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseWhileStm(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.WhileStm), "WhileStm");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.WHILE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WHILE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHILE.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.NOT, TokenType.MINUS, TokenType.PLUS, TokenType.INC, TokenType.DEC, TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.BOOL, TokenType.IDENTIFIER, TokenType.BROPEN);
            if (tok.Type == TokenType.NOT
                || tok.Type == TokenType.MINUS
                || tok.Type == TokenType.PLUS
                || tok.Type == TokenType.INC
                || tok.Type == TokenType.DEC
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DOUBLE
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.BOOL
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.BROPEN)
            {
                ParseExpr(node);
            }

            
            ParseStatements(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseDoStm(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.DoStm), "DoStm");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.DO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DO.ToString(), 0x1001, tok));
                return;
            }

            
            ParseStatements(node);

            
            tok = scanner.Scan(TokenType.WHILE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WHILE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHILE.ToString(), 0x1001, tok));
                return;
            }

            
            ParseExpr(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseForStm(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ForStm), "ForStm");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.FOR);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FOR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOR.ToString(), 0x1001, tok));
                return;
            }

            
            ParseVariable(node);

            
            ParseAssign(node);

            
            tok = scanner.Scan(TokenType.TO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

            
            ParseExpr(node);

            
            tok = scanner.LookAhead(TokenType.INCBY);
            if (tok.Type == TokenType.INCBY)
            {

                
                tok = scanner.Scan(TokenType.INCBY);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.INCBY) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INCBY.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseExpr(node);
            }

            
            ParseStatements(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseReturnStm(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ReturnStm), "ReturnStm");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.RETURN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RETURN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RETURN.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.NOT, TokenType.MINUS, TokenType.PLUS, TokenType.INC, TokenType.DEC, TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.BOOL, TokenType.IDENTIFIER, TokenType.BROPEN);
            if (tok.Type == TokenType.NOT
                || tok.Type == TokenType.MINUS
                || tok.Type == TokenType.PLUS
                || tok.Type == TokenType.INC
                || tok.Type == TokenType.DEC
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DOUBLE
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.BOOL
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.BROPEN)
            {
                ParseExpr(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseOperStm(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.OperStm), "OperStm");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.OPER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OPER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.BROPEN);
            if (tok.Type == TokenType.BROPEN)
            {
                ParseCall(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseCallOrAssign(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CallOrAssign), "CallOrAssign");
            parent.Nodes.Add(node);


            
            ParseVariable(node);

            
            tok = scanner.LookAhead(TokenType.ASSIGN);
            if (tok.Type == TokenType.ASSIGN)
            {
                ParseAssign(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseAssign(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Assign), "Assign");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.ASSIGN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ASSIGN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ASSIGN.ToString(), 0x1001, tok));
                return;
            }

            
            ParseExpr(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseVariable(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Variable), "Variable");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.SQOPEN, TokenType.BROPEN);
            if (tok.Type == TokenType.SQOPEN
                || tok.Type == TokenType.BROPEN)
            {
                tok = scanner.LookAhead(TokenType.SQOPEN, TokenType.BROPEN);
                switch (tok.Type)
                {
                    case TokenType.SQOPEN:
                        ParseArray(node);
                        break;
                    case TokenType.BROPEN:
                        ParseCall(node);
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected SQOPEN or BROPEN.", 0x0002, tok));
                        break;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseArray(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Array), "Array");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.SQOPEN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SQOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQOPEN.ToString(), 0x1001, tok));
                return;
            }

            
            ParseExpr(node);

            
            tok = scanner.Scan(TokenType.SQCLOSE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SQCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQCLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseCall(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Call), "Call");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.BROPEN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BROPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.NOT, TokenType.MINUS, TokenType.PLUS, TokenType.INC, TokenType.DEC, TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.BOOL, TokenType.IDENTIFIER, TokenType.BROPEN);
            if (tok.Type == TokenType.NOT
                || tok.Type == TokenType.MINUS
                || tok.Type == TokenType.PLUS
                || tok.Type == TokenType.INC
                || tok.Type == TokenType.DEC
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DOUBLE
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.BOOL
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.BROPEN)
            {
                ParseArguments(node);
            }

            
            tok = scanner.Scan(TokenType.BRCLOSE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseArguments(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Arguments), "Arguments");
            parent.Nodes.Add(node);


            
            ParseExpr(node);

            
            tok = scanner.LookAhead(TokenType.COMMA);
            while (tok.Type == TokenType.COMMA)
            {

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseExpr(node);
            tok = scanner.LookAhead(TokenType.COMMA);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseLiteral(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Literal), "Literal");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.BOOL);
            switch (tok.Type)
            {
                case TokenType.INTEGER:
                    tok = scanner.Scan(TokenType.INTEGER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INTEGER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.DOUBLE:
                    tok = scanner.Scan(TokenType.DOUBLE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOUBLE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLE.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.BOOL:
                    tok = scanner.Scan(TokenType.BOOL);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BOOL) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BOOL.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected INTEGER, DOUBLE, STRING, or BOOL.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Expr), "Expr");
            parent.Nodes.Add(node);


            
            ParseOrExpr(node);

            
            tok = scanner.LookAhead(TokenType.QUESTION);
            if (tok.Type == TokenType.QUESTION)
            {

                
                tok = scanner.Scan(TokenType.QUESTION);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.QUESTION) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.QUESTION.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseExpr(node);

                
                tok = scanner.Scan(TokenType.COLON);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COLON) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseExpr(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseOrExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.OrExpr), "OrExpr");
            parent.Nodes.Add(node);


            
            ParseAndExpr(node);

            
            tok = scanner.LookAhead(TokenType.OR);
            while (tok.Type == TokenType.OR)
            {

                
                tok = scanner.Scan(TokenType.OR);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.OR) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OR.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseAndExpr(node);
            tok = scanner.LookAhead(TokenType.OR);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseAndExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AndExpr), "AndExpr");
            parent.Nodes.Add(node);


            
            ParseNotExpr(node);

            
            tok = scanner.LookAhead(TokenType.AND);
            while (tok.Type == TokenType.AND)
            {

                
                tok = scanner.Scan(TokenType.AND);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.AND) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AND.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseNotExpr(node);
            tok = scanner.LookAhead(TokenType.AND);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseNotExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.NotExpr), "NotExpr");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.NOT);
            if (tok.Type == TokenType.NOT)
            {
                tok = scanner.Scan(TokenType.NOT);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.NOT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NOT.ToString(), 0x1001, tok));
                    return;
                }
            }

            
            ParseCompExpr(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseCompExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CompExpr), "CompExpr");
            parent.Nodes.Add(node);


            
            ParseAddExpr(node);

            
            tok = scanner.LookAhead(TokenType.COMP);
            if (tok.Type == TokenType.COMP)
            {

                
                tok = scanner.Scan(TokenType.COMP);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMP) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMP.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseAddExpr(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseAddExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AddExpr), "AddExpr");
            parent.Nodes.Add(node);


            
            ParseMultExpr(node);

            
            tok = scanner.LookAhead(TokenType.PLUS, TokenType.MINUS);
            while (tok.Type == TokenType.PLUS
                || tok.Type == TokenType.MINUS)
            {

                
                tok = scanner.LookAhead(TokenType.PLUS, TokenType.MINUS);
                switch (tok.Type)
                {
                    case TokenType.PLUS:
                        tok = scanner.Scan(TokenType.PLUS);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.PLUS) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUS.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.MINUS:
                        tok = scanner.Scan(TokenType.MINUS);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.MINUS) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MINUS.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected PLUS or MINUS.", 0x0002, tok));
                        break;
                }

                
                ParseMultExpr(node);
            tok = scanner.LookAhead(TokenType.PLUS, TokenType.MINUS);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseMultExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MultExpr), "MultExpr");
            parent.Nodes.Add(node);


            
            ParsePowExpr(node);

            
            tok = scanner.LookAhead(TokenType.MULT, TokenType.DIV, TokenType.MOD, TokenType.INTDIV);
            while (tok.Type == TokenType.MULT
                || tok.Type == TokenType.DIV
                || tok.Type == TokenType.MOD
                || tok.Type == TokenType.INTDIV)
            {

                
                tok = scanner.LookAhead(TokenType.MULT, TokenType.DIV, TokenType.MOD, TokenType.INTDIV);
                switch (tok.Type)
                {
                    case TokenType.MULT:
                        tok = scanner.Scan(TokenType.MULT);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.MULT) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULT.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.DIV:
                        tok = scanner.Scan(TokenType.DIV);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.DIV) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIV.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.MOD:
                        tok = scanner.Scan(TokenType.MOD);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.MOD) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MOD.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.INTDIV:
                        tok = scanner.Scan(TokenType.INTDIV);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.INTDIV) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTDIV.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected MULT, DIV, MOD, or INTDIV.", 0x0002, tok));
                        break;
                }

                
                ParsePowExpr(node);
            tok = scanner.LookAhead(TokenType.MULT, TokenType.DIV, TokenType.MOD, TokenType.INTDIV);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParsePowExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.PowExpr), "PowExpr");
            parent.Nodes.Add(node);


            
            ParseUnaryExpr(node);

            
            tok = scanner.LookAhead(TokenType.POW);
            while (tok.Type == TokenType.POW)
            {

                
                tok = scanner.Scan(TokenType.POW);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.POW) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POW.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseUnaryExpr(node);
            tok = scanner.LookAhead(TokenType.POW);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseUnaryExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.UnaryExpr), "UnaryExpr");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.MINUS, TokenType.PLUS, TokenType.INC, TokenType.DEC);
            if (tok.Type == TokenType.MINUS
                || tok.Type == TokenType.PLUS
                || tok.Type == TokenType.INC
                || tok.Type == TokenType.DEC)
            {
                tok = scanner.LookAhead(TokenType.MINUS, TokenType.PLUS, TokenType.INC, TokenType.DEC);
                switch (tok.Type)
                {
                    case TokenType.MINUS:
                        tok = scanner.Scan(TokenType.MINUS);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.MINUS) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MINUS.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.PLUS:
                        tok = scanner.Scan(TokenType.PLUS);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.PLUS) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUS.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.INC:
                        tok = scanner.Scan(TokenType.INC);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.INC) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INC.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.DEC:
                        tok = scanner.Scan(TokenType.DEC);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.DEC) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DEC.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected MINUS, PLUS, INC, or DEC.", 0x0002, tok));
                        break;
                }
            }

            
            ParseAtom(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseAtom(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Atom), "Atom");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.BOOL, TokenType.IDENTIFIER, TokenType.BROPEN);
            switch (tok.Type)
            {
                case TokenType.INTEGER:
                case TokenType.DOUBLE:
                case TokenType.STRING:
                case TokenType.BOOL:
                    ParseLiteral(node);
                    break;
                case TokenType.IDENTIFIER:
                    ParseVariable(node);
                    break;
                case TokenType.BROPEN:

                    
                    tok = scanner.Scan(TokenType.BROPEN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BROPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, tok));
                        return;
                    }

                    
                    ParseExpr(node);

                    
                    tok = scanner.Scan(TokenType.BRCLOSE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRCLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected INTEGER, DOUBLE, STRING, BOOL, IDENTIFIER, or BROPEN.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }


    }

    #endregion Parser
}
